<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Save Phone & Location</title>

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />

  <style>
    :root { --fg:#111; --muted:#555; --brand:#1a73e8; --danger:#c62828; }
    * { box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; color: var(--fg); margin: 0; }
    header { padding: 24px 16px; text-align: center; background: white; position: sticky; top: 0; border-bottom: 1px solid #eee; }
    main { max-width: 720px; margin: 0 auto; padding: 24px 16px 64px; }
    h1 { margin: 0 0 8px; }
    p.muted { color: var(--muted); margin-top: 4px; }
    .card { background: white; border: 1px solid #e6e6e6; border-radius: 14px; padding: 16px; box-shadow: 0 1px 2px rgba(0,0,0,.04); }
    .stack { display: grid; gap: 12px; }
    label { font-weight: 600; display:block; margin-bottom: 6px; }
    input[type="tel"] { width: 100%; padding: 12px; border: 1px solid #d0d0d0; border-radius: 10px; font-size: 16px; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    button { appearance:none; border:0; border-radius: 10px; padding: 10px 16px; font-size: 16px; cursor:pointer; }
    .primary { background: var(--brand); color:white; }
    .danger { background: var(--danger); color:white; }
    .ghost { background: #efefef; }
    #output { min-height: 20px; white-space: pre-wrap; }
    .ok { color: #0a7f2e; }
    .err { color: #b00020; }

    #mapCard { display:none; }
    #mapMeta { display:flex; justify-content:space-between; align-items:center; gap:8px; flex-wrap:wrap; }
    #mapTimestamp { font-weight: 600; }
    #mapCoords { color: var(--muted); font-size: 14px; }
    #map { width: 100%; height: 360px; border-radius: 12px; overflow: hidden; }

    .view { display:none; }
    .view.active { display:block; }
    footer { text-align:center; padding: 16px; color: var(--muted); font-size: 13px; }

    .kv { margin-top:6px; padding:8px; background:#fafafa; border:1px solid #eee; border-radius:10px; font-size:14px; }
    .kv b { font-weight:600; }
    .timer { margin-top:6px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  </style>
</head>
<body>
  <header>
    <h1>Save My Location</h1>
    <p class="muted">
      Rules refresh automatically on each visit. Timers show time since parked and time until next sweeping.
    </p>
  </header>

  <main>
    <!-- SETUP VIEW -->
    <section id="setupView" class="view">
      <div class="card stack">
        <div>
          <label for="setupPhone">Enter your phone number (one time)</label>
          <input id="setupPhone" type="tel" inputmode="tel" placeholder="+1 415 555 0123" autocomplete="tel" />
        </div>
        <div class="row">
          <button id="setupSave" class="primary">Continue</button>
          <span id="setupMsg" class="muted"></span>
        </div>
        <p class="muted">
          We tie your phone to your current public IP and store locally; on save, we also send it to the service.
        </p>
      </div>
    </section>

    <!-- MAIN VIEW -->
    <section id="mainView" class="view">
      <div class="card stack">
        <div class="row" style="justify-content:space-between; align-items:start;">
          <div>
            <div><strong>Phone:</strong> <span id="labelPhone">‚Äî</span></div>
            <div><strong>IP:</strong> <span id="labelIP">(detecting‚Ä¶)</span></div>
          </div>
          <button id="resetOnboarding" class="ghost" title="Forget phone & IP and start over">Reset setup</button>
        </div>

        <div class="row">
          <button id="saveBtn" class="primary">Save current location</button>
          <button id="deleteBtn" class="danger">Delete my entry (local)</button>
        </div>

        <div id="output" class="muted"></div>

        <!-- Display areas -->
        <div id="parkingBox" class="kv" style="display:none;"></div>
        <div id="sweepingBox" class="kv" style="display:none;"></div>
      </div>

      <!-- Map + timestamp -->
      <div id="mapCard" class="card stack" style="margin-top:12px;">
        <div id="mapMeta">
          <div id="mapTimestamp">‚Äî</div>
          <div id="mapCoords" class="muted">‚Äî</div>
        </div>
        <div id="map"></div>
        <div class="muted" style="font-size:12px;">
          Map data ¬© <a href="https://www.openstreetmap.org/" target="_blank" rel="noopener">OpenStreetMap</a> contributors
        </div>
      </div>
    </section>
  </main>

  <footer>
    Privacy: phone, IP, and location are stored in your browser and (on save) also sent to this service for admin viewing.
  </footer>

  <!-- Leaflet JS -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <script>
    /* ======================== CONFIG ======================== */
    const API_BASE     = "https://locationretrievalpoc.onrender.com";
    const SUBMIT_URL   = API_BASE + "/api/submit";
    const CHECK_IP_API = "https://api.ipify.org?format=json";

    /* ================== Local storage helpers ================= */
    const PHONE_KEY  = "userPhone";
    const IP_KEY     = "userIP";
    const RECORD_KEY = "submission";

    const setupView       = document.getElementById("setupView");
    const mainView        = document.getElementById("mainView");
    const setupPhone      = document.getElementById("setupPhone");
    const setupSave       = document.getElementById("setupSave");
    const setupMsg        = document.getElementById("setupMsg");
    const labelPhone      = document.getElementById("labelPhone");
    const labelIP         = document.getElementById("labelIP");
    const saveBtn         = document.getElementById("saveBtn");
    const deleteBtn       = document.getElementById("deleteBtn");
    const resetOnboarding = document.getElementById("resetOnboarding");
    const output          = document.getElementById("output");
    const mapCard         = document.getElementById("mapCard");
    const mapTimestampEl  = document.getElementById("mapTimestamp");
    const mapCoordsEl     = document.getElementById("mapCoords");
    const parkingBox      = document.getElementById("parkingBox");
    const sweepingBox     = document.getElementById("sweepingBox");

    let map, marker;
    let parkingInterval  = null;
    let sweepingInterval = null;

    function normalizePhone(raw) { return (raw || "").replace(/[^\d+]/g, ""); }
    function getPhone()          { return localStorage.getItem(PHONE_KEY) || null; }
    function setPhone(v)         { localStorage.setItem(PHONE_KEY, v); }
    function getIP()             { return localStorage.getItem(IP_KEY) || null; }
    function setIP(v)            { localStorage.setItem(IP_KEY, v); }

    function readRecord() {
      try { return JSON.parse(localStorage.getItem(RECORD_KEY) || "null"); }
      catch { return null; }
    }
    function writeRecord(obj) {
      localStorage.setItem(RECORD_KEY, JSON.stringify(obj, null, 2));
      renderMapFromSaved();
    }
    function clearRecord() {
      localStorage.removeItem(RECORD_KEY);
      renderMapFromSaved();
    }

    function switchView(name) {
      for (const el of document.querySelectorAll(".view")) el.classList.remove("active");
      document.getElementById(name).classList.add("active");
    }

    async function detectIP() {
      try {
        const c = await fetch(CHECK_IP_API, { cache: "no-store" });
        if (!c.ok) throw new Error();
        const { ip } = await c.json();
        return ip || null;
      } catch { return null; }
    }

    async function ensureIPStored() {
      let ip = getIP();
      if (!ip) {
        labelIP.textContent = "detecting‚Ä¶";
        ip = await detectIP();
        if (ip) { setIP(ip); labelIP.textContent = ip; }
        else    { labelIP.textContent = "(unavailable)"; }
      } else {
        labelIP.textContent = ip;
      }
    }

    /* ===================== Map rendering ===================== */
    function initMapIfNeeded(lat, lng) {
      if (!map) {
        map = L.map("map");
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          maxZoom: 19,
          attribution: "&copy; OpenStreetMap contributors",
        }).addTo(map);
      }
      map.setView([lat, lng], 15);
      if (!marker) marker = L.marker([lat, lng]).addTo(map);
      else marker.setLatLng([lat, lng]);
      setTimeout(() => map && map.invalidateSize(), 50);
    }

    function renderMap(record) {
      if (!record) { mapCard.style.display = "none"; return; }
      mapCard.style.display = "block";
      mapTimestampEl.textContent = new Date(record.timestamp).toLocaleString();
      mapCoordsEl.textContent   = `üìç ${record.latitude}, ${record.longitude}  ‚Ä¢  ¬±${record.accuracy ?? "?"}m`;
      initMapIfNeeded(record.latitude, record.longitude);
    }
    function renderMapFromSaved() { renderMap(readRecord()); }

    /* ======================== Time utils ======================== */

    // Day names to 0..6
    const DAY_MAP = {
      "sun":0, "sunday":0,
      "mon":1, "monday":1,
      "tue":2, "tues":2, "tuesday":2,
      "wed":3, "wednesday":3,
      "thu":4, "thur":4, "thurs":4, "thursday":4,
      "fri":5, "friday":5,
      "sat":6, "saturday":6
    };

    function parseDays(daysStr) {
      if (!daysStr) return null;
      const s = String(daysStr).toLowerCase().replace(/\s+/g, "").replace(/&/g, ",");
      const result = new Set();

      for (const part of s.split(",")) {
        if (!part) continue;

        if (part.includes("-")) {
          const [a, b] = part.split("-");
          const start = DAY_MAP[a], end = DAY_MAP[b];
          if (start == null || end == null) continue;
          let d = start;
          while (true) {
            result.add(d);
            if (d === end) break;
            d = (d + 1) % 7;
          }
        } else {
          const d = DAY_MAP[part];
          if (d != null) result.add(d);
        }
      }
      return result.size ? result : null;
    }

    function hhmmToHours(n) {
      const v = Number(n);
      if (!Number.isFinite(v)) return null;
      if (v >= 100) {
        const hh = Math.floor(v / 100);
        const mm = v % 100;
        return hh + (mm / 60);
      }
      return v;
    }

    // Extract a [from,to) window from rule
    function getWindowFromTo(rule) {
      const rawFrom = rule.fromTime ?? rule.fromHour ?? null;
      const rawTo   = rule.toTime   ?? rule.toHour   ?? null;

      let from = hhmmToHours(rawFrom);
      let to   = hhmmToHours(rawTo);

      if (from == null || to == null) {
        const windowStr = String(rule.hours || rule.timeWindow || "").replace(/\s/g, "");
        const m = windowStr.match(/(\d{1,4})\s*[‚Äì-]\s*(\d{1,4})/);
        if (m) { from = hhmmToHours(m[1]); to = hhmmToHours(m[2]); }
      }

      if (from == null || to == null) return null;
      from = Math.max(0, Math.min(24, from));
      to   = Math.max(0, Math.min(24, to));
      return { from, to };
    }

    function isWithinWindow(from, to, date = new Date()) {
      const h = date.getHours() + date.getMinutes() / 60 + date.getSeconds() / 3600;
      return (from <= to) ? (h >= from && h < to) : (h >= from || h < to); // handles wrap past midnight
    }

    function isTodayAllowed(daysStr, date = new Date()) {
      const set = parseDays(daysStr);
      if (!set) return true;
      return set.has(date.getDay());
    }

    function humanHMS(ms) {
      const s  = Math.max(0, Math.floor(ms / 1000));
      const hh = Math.floor(s / 3600).toString().padStart(2, "0");
      const mm = Math.floor((s % 3600) / 60).toString().padStart(2, "0");
      const ss = Math.floor(s % 60).toString().padStart(2, "0");
      return `${hh}:${mm}:${ss}`;
    }

    function weekOfMonth(date) {
      // 1..5, weeks start Sunday
      const first = new Date(date.getFullYear(), date.getMonth(), 1).getDay(); // 0..6
      return Math.floor((date.getDate() + first - 1) / 7) + 1;
    }

    function findNextSweepingDate(s) {
      // s.weekday (string),
      // s.weeks: {1..5:true/false},
      // s.fromHour / s.toHour (numbers like 9, 11 or 900, 1100)
      const wd = (s.weekday || "").toLowerCase();
      const targetDow = DAY_MAP[wd] ?? null;
      if (targetDow == null) return null;

      const hasWeekFlags = s.weeks && Object.values(s.weeks).some(Boolean);
      const now = new Date();

      for (let addMonth = 0; addMonth < 2; addMonth++) {
        const base = new Date(now.getFullYear(), now.getMonth() + addMonth, 1, 0, 0, 0, 0);
        const year = base.getFullYear();
        const month = base.getMonth();

        for (let day = 1; day <= 31; day++) {
          const dt = new Date(year, month, day, 0, 0, 0, 0);
          if (dt.getMonth() !== month) break;
          if (dt.getDay() !== targetDow) continue;

          const wk = weekOfMonth(dt);
          if (hasWeekFlags && !s.weeks[wk]) continue;

          const fromHour = (s.fromHour != null) ? Number(s.fromHour) : 0;
          const start = new Date(year, month, day, hhmmToHours(fromHour) || 0, 0, 0, 0);

          if (start.getTime() >= now.getTime()) return start;
        }
      }
      return null;
    }

    /* ====================== Render helpers ====================== */
    function renderParking(rule, record) {
      if (parkingInterval) { clearInterval(parkingInterval); parkingInterval = null; }
      if (!rule) { parkingBox.style.display = "none"; return; }

      let html = `<b>Nearest parking rule</b> <span class="muted">(${rule.distanceMeters}m)</span><br>`;
      html += `${rule.regulation || "(unspecified)"}<br>`;
      if (rule.days)      html += `<b>Days:</b> ${rule.days} `;
      if (rule.hours)     html += ` <b>Hours:</b> ${rule.hours}`;
      if (rule.exceptions)html += `<br><b>Notes:</b> ${rule.exceptions}`;
      html += `<div id="parkingTimer" class="timer" style="display:none;"></div>`;

      parkingBox.innerHTML = html;
      parkingBox.style.display = "block";

      // Only show count-up while inside the restriction window (today + hours)
      if (!record || !record.timestamp) return;
      const window = getWindowFromTo(rule);
      const now    = new Date();
      const within = window && isTodayAllowed(rule.days || "", now) && isWithinWindow(window.from, window.to, now);

      if (within) {
        const el = document.getElementById("parkingTimer");
        el.style.display = "block";
        const parkedAt = new Date(record.timestamp).getTime();

        const tick = () => {
          el.textContent = `‚è±Ô∏è Time since parked (within restriction): ${humanHMS(Date.now() - parkedAt)}`;
        };
        tick();
        parkingInterval = setInterval(tick, 1000);
      }
    }

    function renderSweeping(s) {
      if (sweepingInterval) { clearInterval(sweepingInterval); sweepingInterval = null; }
      if (!s) { sweepingBox.style.display = "none"; return; }

      let html = `<b>Street sweeping</b> <span class="muted">(${s.distanceMeters}m)</span><br>`;
      const street = [s.street, s.limits].filter(Boolean).join(" ‚Äî ");
      html += `${street}<br>`;
      if (s.side)      html += `<b>Side:</b> ${s.side} `;
      if (s.weekday)   html += `<b>Day:</b> ${s.weekday} `;
      if (s.timeWindow)html += `<b>Time:</b> ${s.timeWindow} `;
      if (s.weeksText) html += `<b>Weeks:</b> ${s.weeksText} `;
      if (s.holidays)  html += `<span class="muted">(runs on holidays)</span>`;

      html += `<div id="sweepingTimer" class="timer" style="display:block;"></div>`;
      sweepingBox.innerHTML = html;
      sweepingBox.style.display = "block";

      const next = findNextSweepingDate(s);
      const el   = document.getElementById("sweepingTimer");

      if (!next) {
        el.textContent = "‚è≥ Next sweeping time: unavailable";
        return;
      }

      const humanCountdown = (ms) => {
        const total = Math.max(0, Math.floor(ms / 1000));
        const d = Math.floor(total / 86400);
        const h = Math.floor((total % 86400) / 3600).toString().padStart(2, "0");
        const m = Math.floor((total % 3600) / 60).toString().padStart(2, "0");
        const s = Math.floor(total % 60).toString().padStart(2, "0");
        return (d ? d + "d " : "") + `${h}:${m}:${s}`;
      };

      const tick = () => {
        const ms = next.getTime() - Date.now();
        if (ms <= 0) {
          el.textContent = "üöß Sweeping in effect now";
          clearInterval(sweepingInterval);
          sweepingInterval = null;
        } else {
          el.textContent = `‚è≥ Time until next sweeping: ${humanCountdown(ms)} (at ${next.toLocaleString()})`;
        }
      };

      tick();
      sweepingInterval = setInterval(tick, 1000);
    }

    /* ============== Refresh regs on page load if saved ============== */
    async function recheckRegulationsFromSaved() {
      const rec = readRecord();
      if (!rec || typeof rec.latitude !== "number" || typeof rec.longitude !== "number") return;

      // Show cached view first
      renderMap(rec);
      renderParking(rec.rule || null, rec);
      renderSweeping(rec.sweep || null);

      try {
        const res = await fetch(SUBMIT_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ latitude: rec.latitude, longitude: rec.longitude }),
        });
        if (!res.ok) throw new Error(`Server ${res.status}`);
        const data = await res.json();

        renderParking(data.rule || null, rec);
        renderSweeping(data.sweep || null);

        writeRecord({
          ...rec,
          rule: data.rule || null,
          sweep: data.sweep || null,
          lastChecked: new Date().toISOString(),
        });
      } catch (e) {
        console.warn("Recheck failed:", e.message);
      }
    }

    /* ========================== INIT + UI ========================== */
    async function init() {
      const phone = getPhone();
      if (!phone) {
        switchView("setupView");
        const ip = await detectIP(); if (ip) setIP(ip);
      } else {
        labelPhone.textContent = phone;
        await ensureIPStored();
        switchView("mainView");

        // Any saved record?
        renderMapFromSaved();
        const rec = readRecord();
        renderParking(rec?.rule || null, rec || null);
        renderSweeping(rec?.sweep || null);

        // Always refresh from backend with saved lat/lon
        recheckRegulationsFromSaved();
      }
    }

    setupSave.addEventListener("click", async () => {
      setupMsg.className = "muted";
      setupMsg.textContent = "Validating‚Ä¶";

      const phone = normalizePhone(setupPhone.value);
      if (!phone || phone.length < 7) {
        setupMsg.className = "err";
        setupMsg.textContent = "Please enter a valid phone number.";
        return;
      }
      setPhone(phone);
      labelPhone.textContent = phone;
      await ensureIPStored();

      setupMsg.textContent = "";
      switchView("mainView");
      renderMapFromSaved();
      recheckRegulationsFromSaved();
    });

    resetOnboarding.addEventListener("click", () => {
      if (!confirm("Forget your stored phone and IP on this device?")) return;
      localStorage.removeItem(PHONE_KEY);
      localStorage.removeItem(IP_KEY);
      localStorage.removeItem(RECORD_KEY);
      location.reload();
    });

    saveBtn.addEventListener("click", async () => {
      output.className = "muted";
      output.textContent = "Requesting location‚Ä¶";

      if (!("geolocation" in navigator)) {
        output.className = "err";
        output.textContent = "Geolocation is not supported by this browser.";
        return;
      }

      const phone = getPhone();
      if (!phone) {
        output.className = "err";
        output.textContent = "No phone on file. Please complete setup.";
        switchView("setupView");
        return;
      }

      let ip = getIP();
      if (!ip) { ip = await detectIP(); if (ip) setIP(ip); }

      const options = { enableHighAccuracy: true, timeout: 15000, maximumAge: 0 };
      navigator.geolocation.getCurrentPosition(async (pos) => {
        const { latitude, longitude, accuracy } = pos.coords;
        const record = {
          phone,
          ip: ip || "(unavailable)",
          latitude: Number(latitude.toFixed(6)),
          longitude: Number(longitude.toFixed(6)),
          accuracy: Number.isFinite(accuracy) ? Math.round(accuracy) : null,
          timestamp: new Date().toISOString(),
        };

        writeRecord(record);
        renderMap(record);

        try {
          const res = await fetch(SUBMIT_URL, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(record),
          });
          if (!res.ok) throw new Error(`Server ${res.status}`);
          const data = await res.json();

          output.className = "ok";
          output.textContent = "Saved locally and sent to service.";
          renderParking(data.rule || null, record);
          renderSweeping(data.sweep || null);

          writeRecord({
            ...record,
            rule: data.rule || null,
            sweep: data.sweep || null,
            lastChecked: new Date().toISOString(),
          });
        } catch (e) {
          output.className = "err";
          output.textContent = `Saved locally, but failed to send to service: ${e.message}`;
          renderParking(null, record);
          renderSweeping(null);
        }
      }, (err) => {
        output.className = "err";
        if (err.code === err.PERMISSION_DENIED)    output.textContent = "Permission denied. Please allow location access.";
        else if (err.code === err.POSITION_UNAVAILABLE) output.textContent = "Location unavailable.";
        else if (err.code === err.TIMEOUT)          output.textContent = "Timed out getting location.";
        else                                        output.textContent = "Unknown error getting location.";
      }, options);
    });

    deleteBtn.addEventListener("click", () => {
      const rec = readRecord();
      if (rec) { clearRecord(); output.className = "ok"; output.textContent = "Deleted your saved location entry (local only)."; }
      else     { output.className = "err"; output.textContent = "No saved entry to delete."; }

      if (parkingInterval)  { clearInterval(parkingInterval);  parkingInterval  = null; }
      if (sweepingInterval) { clearInterval(sweepingInterval); sweepingInterval = null; }
      renderParking(null, null);
      renderSweeping(null);
    });

    init();
  </script>
</body>
</html>
